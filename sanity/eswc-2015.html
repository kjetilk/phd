<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <base href="http://0.0.0.0:8000/"/>
    <title>A survey of HTTP caching implementations on the open Semantic Web</title>
    
    <meta name="description" content="Scalability of the data access architecture in the Semantic Web is
dependent on the establishment of caching mechanisms to take the load
off of servers.  Unfortunately, there is a chicken and egg problem
here: Research, implementation, and evaluation of caching
infrastructure is uninteresting as long as data providers do not
publish relevant metadata.  And publishing metadata is useless as long
as there is no infrastructure that uses it.

We show by means of a survey of live RDF data sources that caching
metadata is prevalent enough already to be used in some cases.  On the
other hand, they are not commonly used even on relatively static data,
and when they are given, they are very conservatively set. We point
out future directions and give recommendations for the enhanced use of
caching in the Semantic Web."/>
    <meta name="author" content="Kjetil Kjernsmo"/>
    
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    
    <link rel="stylesheet" href="css/reveal.css"/>
    <link rel="stylesheet" href="css/theme/black.css" id="theme"/>
    
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css"/>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    
    
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>
  
  <body>
    
    <div class="reveal">
      
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
	<section>
	  <h1>A survey of HTTP caching implementations on the open Semantic Web</h1>
	  <p>
	    Kjetil
            Kjernsmo, <a href="http://folk.uio.no/kjekje/#cache-survey">http://folk.uio.no/kjekje/#cache-survey</a>,
          </p><p><small>Department of Informatics, University of
            Oslo, Norway </small>
	  </p>

        </section>
 
        <section>
	  <section>
            <h2>Motivation and take-away</h2>
            
            <p>The HTTP standard and Internet infrastucture has good
              facilities, we shouldn't speculate on whether they can be
              used.</p>
            
            <p class="fragment">Support for it is not as good as I hoped, but not as bad
              as I feared.</p>
            <p class="fragment">Please check that you're doing it right!</p>
            
            <aside class="notes">
              <ul><li>
                  I would like to avoid conversations ending up in "nobody
                  is exposing caching information, so it can't be used" or
                  "it is so widespread, it will have great benefits"</li>
                <li>I suspect it isn't that well understood in this
                  community</li>
              </ul>
            </aside>

          </section>

          <section>
            <h2>Questions to be answered</h2>

            <ul>
              <li>How prevalent is support for caching?</li>
              <li>Are certain implementations better than others?</li>
              <li>How long may resources be cached?</li>
              <li>Does it matter whether it is linked data, a SPARQL
              endpoint, etc?</li>
              <li>Can lifetimes be estimated any other way?</li>
            </ul>

          </section>


        </section>
        
	<section>
          <section>
            <h2>Caching in HTTP and the Internet</h2>
            
            <p>
              From <a href="http://tools.ietf.org/html/rfc7234">RFC 7234</a>:  
            </p>
            <blockquote><p> 
              The goal of caching in HTTP/1.1 is to significantly improve
              performance by reusing a prior response message to satisfy a current
              request.
            </p></blockquote>

            <aside class="notes">
              Not just for long-living resources: if you have 10000
              requests/second and it can be cached for a minute, it is
              a big win
            </aside>
          </section>
          <!-- section>
            <h3>Caching prominently featured</h3>
            <ul>
              <li><a href="http://www.w3.org/TR/webarch/">Architecture
              of the World Wide Web, Volume One</a></li>
              <li>Motivates <a
              href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">Representational
              State Transfer (REST)</a>.</li>
              <li>Many other documents</li>
            </ul>
          </section -->
          <!-- section>
            <h3>Current HTTP specifications</h3>
	    <ul>
	      <li><a href="//tools.ietf.org/html/rfc7230">RFC 7230</a> - HTTP/1.1: Message Syntax and Routing</li>
	      <li class="fragment"><a href="//tools.ietf.org/html/rfc7231">RFC 7231</a> - HTTP/1.1: Semantics and Content</li>
	      <li class="fragment"><a href="//tools.ietf.org/html/rfc7232">RFC 7232</a> - HTTP/1.1: Conditional Requests</li>
	      <li class="fragment"><a href="//tools.ietf.org/html/rfc7233">RFC 7233</a> - HTTP/1.1: Range Requests</li>
	      <li class="fragment"><a href="//tools.ietf.org/html/rfc7234">RFC 7234</a> - HTTP/1.1: Caching</li>
	      <li class="fragment"><a href="//tools.ietf.org/html/rfc7235">RFC 7235</a> - HTTP/1.1: Authentication</li>
	    </ul>
            <aside class="notes">
              <p>All published in 2014, replacing RFC 2616 and
              others</p><p>HTTP/2 finalized in May 2015. Doesn't
              change anything for this paper, but opens interesting
              directions for research</p>
            </aside>
            
	  </section -->
          <section>
            <h3>Caching vs. Conditional Requests</h3>
            
            <dl>
              <dt>Caching (defined in <a href="//tools.ietf.org/html/rfc7234">RFC 7234</a>)</dt>
              <dd>HTTP headers where the server says how
              long the server thinks the response will remain
              valid</dd>

              <dt>Conditional Requests (defined in <a href="//tools.ietf.org/html/rfc7232">RFC 7232</a>)</dt>
              <dd>A mechanism where a client asks the server: "is the
              response I have still valid?"</dd>
            </dl>
            
            <aside class="notes">
              <p>First case, no further communication is needed, but
              the server will have to estimate.</p>
              <p>Second case, a request must be made, the server will
              decide whether to reply with a body.</p>
              <p>Caching is prominently featured in many documents,
              but these are specs</p>
            </aside>
            
          </section>
            
          <section>
            <h3>Most relevant HTTP headers &ndash; Caching</h3>
            
              <dl>
                <dt><tt>Cache-Control</tt></dt>
                <dd>For fine-grained control, values including
                <tt>max-age</tt> and <tt>no-store</tt>.</dd>
                <dt><tt>Expires</tt></dt>
                <dd>A time for when the response should not be
                used</dd>
              </dl>

 
              <aside class="notes">
                <ul>
                  <li>
                    HTTP requests and responses have headers and a body. For
                    our purpose, the most important headers are:
                  </li>
                  <li>Caching headers are mostly response headers</li>
                  <li>Based on Cache-control or expires, a freshness
                  lifetime may be computed. </li>
                </ul>

              </aside>
          </section>
          <section>
            <h3>Most relevant HTTP headers &ndash; Conditional requests</h3>

              <h4>Response headers</h4>
              <dl>
                <dt><tt>ETag</tt></dt>
                <dd>An opaque validator for the response</dd>
                <dt><tt>Last-Modified</tt></dt>
                <dd>A timestamp giving the time of modificaton of the
                resource</dd>
              </dl>

              <h4>Request headers</h4>
              <dl>
                <dt><tt>If-None-Match</tt></dt>
                <dd>Check the opaque validator</dd>
                <dt><tt>If-Modified-Since</tt></dt>
                <dd>Give a timestamp to check if the resource has changed.</dd>
              </dl>
 
              <aside class="notes">
                <p>First a request has been made, and the resource has
                been retrieved with the response headers. </p><p> When
                we want to check</p><p>Respond with the body if it has
                changed, if not, just status 304 Not Modified</p>
              </aside>

          </section>

          <section>
            <h3>Freshness lifetime</h3>
            
            <p>
              Number of seconds that the response may be used
              without contacting the origin server.
            </p>

 
              <aside class="notes">
                <ul>                
                  <li>When Based on Cache-control or expires, we shall
                  call this standards-compliant caching. </li>
                </ul>

              </aside>

          </section>

          <section>
            <h3>Heuristic freshness lifetime</h3>

            <p>RFC7234 allows for heuristics to be used to estimate
            freshness lifetime.</p>

            <p>Also suggests a useful heuristic based on <tt>Last-Modified</tt>.</p>

            <p>We might also use RDF data or machine learning to
            estimate.</p>
          </section>
              
        </section>

        <section>
          <section>
            <h2>Methodology</h2>
            
            <p>Gather as many different hosts as we could and send HTTP
            requests to them and record relevant data.</p>
            
            <p>Classify resources into </p>
            <ol>
              <li>Dataset descriptions</li>
              <li>SPARQL Endpoints</li>
              <li>Vocabularies</li>
              <li>Generic information resources</li>
            </ol>
          </section>
          
          <section>
            <h3>Gathering hosts</h3>
            
            <p>To decide where to go, we used:</p>
            <ul>
              <li><a href="http://lov.okfn.org/">Linked Open
              Vocabularies</a></li>
              <li><a href="http://prefix.cc/"><tt>prefix.cc</tt></a></li>
              <li><a href="http://sparqles.ai.wu.ac.at/">SPARQLES
              survey</a></li>
              <li><a href="http://km.aifb.kit.edu/projects/btc-2014/">Billion
              Triples Challenge 2014</a></li>
            </ul>
            

            <p class="fragment"><strong>Got a list of 3117 unique hosts, and
            did 7745 HTTP requests</strong></p>

            <aside class="notes">
              <p>Amongst these, the BTC-2014 is by far the largest, with
              4 GTriples, it represents the breadth, the others are
              small curated datasets.</p>
              <p>Then the data was scanned with a combination of Perl,
              UNIX grep with fair amounts of manual inspection done</p>
              <p><strong>Go right</strong></p>  
            </aside>

          </section>

          <section>
            <h3>Why isn't it bigger?</h3>
            <ul>
              <li>We only included valid data</li>

              <li class="fragment"><strong>Important
              assumption:</strong> Cache headers are set mostly on a
              per-host basis.</li>
              <li class="fragment">Not the RDFa Web</li>
              <li class="fragment">Others do not report per-host
              statistics, but LODstats has 4442 error-free datasets</li>
            </ul>

            <aside class="notes">
              <p>Hurts to say, but semweb isn't bigger</p>
            </aside>
          </section>

          <section>
            <h3>Possible biases</h3>
            <ul>
              <li>Biases may have been introduced by the coverage and
              data reduction.</li>
              
              <li class="fragment">Biases due to discarding momentarily dysfunctinal
              parts of the Semantic Web was not investigated.</li>
              
              <li class="fragment">Other possible biases are considered in a companion
              technical report.</li>
            </ul>
            
          </section>
          
        </section>

        <section>
          <section>
            <h2>Analysis</h2>
            
            <ol>
              <li>Distribution of freshness lifetime
              <ol>
                <li>Standards-compliant</li>
                <li>Simple heuristic</li>
              </ol>
              </li>
              <li>Dublin Core properties</li>
              <li>Do certain server implementations provide better
              caching support than others?</li>
              <li>Cache (re)validation</li>
            </ol>

            <aside class="notes">
              <p>Focused on descriptive statistics, how frequent
              caching headers are found, how long freshness lifetimes
              are, ease of finding heuristics, possible to
              revalidate</p>
              <p>We also do statistical hypotheses tests using
              so-called contingency tables</p>
            </aside>
          </section>

          
          <section>
            <h3>Successful responses</h3>
            
            <p>We had 2965 successful responses</p>
            
            <div>
              <p>Successful response defined as</p>
              
              <ul>
                <li>Successful HTTP Response (after redirects)</li>
                <li>Valid RDF media type or SPARQL result</li>
                <li>Must parse into an RDF Model</li>
              </ul>
            </div>

            <aside class="notes">
              <p>Quickly: A successful response is rather strictly
              defined</p>
            </aside>
                
          </section>
          
          <section>
            <h3>Standards-compliant caching in numbers</h3>
            
            <ul>
              <li><strong>405</strong> resources returned parsable cache
              headers</li>
              <li class="fragment"><strong>114</strong> did so to
              prohibit caching</li>
              <li class="fragment"><strong>3</strong> contained
              conflicting headers</li>
              <li class="fragment">Usually <tt>Cache-Control</tt> and
              <tt>Expires</tt> both occurred, former most common.</li>
              <li class="fragment"><strong>269</strong> used
              <tt>Cache-Control</tt> for other purposes than freshness lifetime</li>
            </ul>
            
            
            <aside class="notes">
              <p>Look at level of support</p>
              <p>Reminder: Expires or Cache-Control with max-age</p>
              <p>Cache-Control to mandate revalidation, prohibition,
              only private caches may use the response, etc.</p>
            </aside>

          </section>

          <section>
            <h3>Standards-compliant freshness lifetime</h3>
            
            <figure>
              <img src="sanity/hardall.png" alt="Standards-compliant
                                          freshness lifetime"/>
            </figure>
            
            <aside class="notes">
              <ul>
                <li>Barplot: horizontal axis is divided up unevenly,
                in time bins, 1-59 sec, 60-3599 sec, etc. To make it
                clear, I chose the lesser evil, <a
                href="http://www.scientificamerican.com/article/experts-time-division-days-hours-minutes/">blame
                the egyptians and babylonians</a>.</li>  <li>vertical axis
                is the number of times a certain freshness lifetime
                was found.
                </li>
                <li>Cache prohibition is most common. Minutes to days
                also common.</li>
              </ul>
            </aside>
                
          </section>
          
          <section>
            <h3>Standards-compliant freshness lifetime</h3>
            
            <figure>
              <img src="sanity/hardtable.png" alt="Standards-compliant
                                                   freshness lifetime"/>
            </figure>
            
            <aside class="notes">
              <ul>
                <li>Breaking up by type: vocabs (light orange),
                generic resources (dark orange), datasets (dark
                violet), SPARQL endpoints (light blue)</li>
                <li>Width of column proportional to occurances.</li>
                <li>Height of boxes proportional to category
                abundance</li>
                <li>Endpoints are in the minutes.</li>
                <li>Datasets are prohibited. Bad idea: Costly to
                compute. Void is estimates</li>
                <li>Very little beyond days.</li>
                <li>Quite different distribution for different
                types. Contigency table can be used, even if a little
                contrived, p-value = 0.00001</li>
              </ul>
            </aside>
          </section>
          
                    
          <section>
            <h3>Simple heuristic freshness lifetime</h3>
            
            <figure>
              <img src="sanity/heuristicall.png" alt="Simple heuristic
                                                      freshness lifetime"/>
            </figure>
            
            <aside class="notes">
              <ul>
                <li>Found simple heuristic freshness for 554
                resources. Many more than standards-based. Based on
                actual modification times</li>
                <li>Now 60% is in the month range. Agreeing with
                Dynamic Linked Data Observatory</li>
                <li>We could also still verify 911 resources where
                last-modified and/or Etag that were recorded by the
                BTC crawl months prior to our crawl as fresh.
                </li>
                <li>This gives a better picture of the actual change
                frequency</li>
              </ul>
            </aside>
            
          </section>

          <section>
            <h3>Simple heuristic freshness lifetime</h3>
            
            <figure>
              <img src="sanity/heuristictable.png" alt="Simple heuristic
                                                        freshness lifetime"/>
            </figure>
                        
            <aside class="notes">
              <ul>
                <li>First note that the types are rather similar,
                confirmed by test p = 0.02, still quite different</li>
                <li>Just one endpoint had last-modified, could be that
                DBMSes aren't helping in tracking</li>
              </ul>
            </aside>
            
          </section>

          <section>
            <h3>Dublin Core properties</h3>

            <table>
              <tr><th>Predicate</th><th>Number of occurences</th></tr>
              <tr><th><tt>dct:modified</tt></th><td style="text-align:
              right" class="fragment">2687</td></tr>
              <tr><th><tt>dct:valid   </tt></th><td  style="text-align:
              right" class="fragment">21</td></tr>
              <tr><th><tt>dct:accrualPeriodicity   </tt></th><td  style="text-align:
              right" class="fragment">2</td></tr>
              <tr><th><tt>dct:date </tt></th><td  style="text-align:
              right" class="fragment">36</td></tr>
              <tr><th><tt>dct:created</tt></th><td  style="text-align:
              right" class="fragment">389</td></tr>
              <tr><th><tt>dct:issued</tt></th><td style="text-align:
              right" class="fragment">1475 </td></tr>
            </table>

            <aside class="notes">
              <ul>
                <li>Modified, 2487 has a different subject then the
                request-URI, so, they probably describe a
                sub-graph. Latest date may be used.</li>
                <li>valid could replace expires, but none were in the
                future.</li>
                <li>periodicity, no machine readable.</li>
                <li>All roughly like date header, which is always
                present, but perhaps something for further study</li>
              </ul>
            </aside>

          </section>

          <section>
            <h3>Cache validation</h3>

            <h4>In our excerpt from BTC-2014:</h4>
            <ul>
              <li>1733 had <tt>ETag</tt></li>
              <li>690 had <tt>Last-Modified</tt></li>
              <li>with great overlap</li>
              <li>911 were still verified as fresh</li>
            </ul>
            

            <aside class="notes">
              <p>BTC crawl was from February to June 2014</p>
              <p>This is pretty good</p>
            </aside>

              
          </section>

          <section>
            <h3>Cache validation</h3>

            <h4>In initial responses:</h4>

            <ul>
              <li>1260 had <tt>ETag</tt>
              <ul>
                <li>606 for vocabularies</li>
                <li>117 for datasets</li>
                <li>12 for endpoints</li>
                <li>525 for unclassified</li>
              </ul>
              </li>
            </ul>
            <aside class="notes">
              <p>The initial requests contained no headers that were
              set based on previous responses, and then, the initial
              responses contained</p>
            </aside>
          </section>

          <section>
            <h3>Conditional request support</h3>
            
            <p>Another 1822 requests to check if conditional requests
            were actually supported</p>

            <p>Found 85 faulty implementations</p>

            <aside class="notes">
              <p>One thing is to expose a header, another is to
              implement some logic, so we checked if they actually
              returned the 304 response where they should</p>
            </aside>

          </section>

          <section>
            <h3><tt>Server</tt>-headers</h3>

            <table style="font-size:small">
             
              <tr><td> DFE/largefile</td></tr> 
              <tr><td> git_frontend</td></tr> 
              <tr data-fragment-index="1" class="fragment grow"><td> nginx/1.3.9</td></tr> 
              <tr><td> thin 1.6.0 codename Greek Yogurt</td></tr> 
              <tr><td> Oracle-Application-Server-10g/10.1.3.4.0 Oracle-HTTP-Server</td></tr>
              <tr><td> Oracle-Application-Server-10g/10.1.3.4.0 Oracle-HTTP-Server</td></tr>
              <tr><td> TwistedWeb/8.2.0</td></tr> 
              <tr data-fragment-index="7" class="fragment grow"><td> RDF::Endpoint/0.07</td></tr> 
              <tr><td> Jetty(6.1.26)</td></tr> 
              <tr><td> nginx/1.6.1</td></tr> 
              <tr><td> Jigsaw/2.3.0-beta3</td></tr> 
              <tr data-fragment-index="3" class="fragment grow"><td>
                Apache/2.2.9 (Win32) PHP/5.2.6</td></tr> 
              <tr><td> Apache/2.4.10 (Unix) mod_fcgid/2.3.9</td></tr> 
              <tr><td> &nbsp; </td></tr> 
              <tr><td> GFE/2.0</td></tr> 
              <tr data-fragment-index="6" class="fragment grow"><td> RDF::LinkedData/0.70</td></tr> 
              <tr data-fragment-index="4" class="fragment grow"><td> Apache/2.2.17 (Unix) mod_wsgi/3.3 Python/2.6.6</td></tr> 
              <tr><td data-fragment-index="5" class="fragment grow"> Virtuoso/07.10.3211 (Linux) i686-generic-linux-glibc212-64  VDB</td></tr> 
              <tr><td> Apache/2.2.24 (Unix) mod_ssl/2.2.24 OpenSSL/0.9.8y</td></tr> 
              <tr data-fragment-index="2" class="fragment grow"><td> Apache/2.2.22 (Fedora)</td></tr> 
              <tr><td> INSEE</td></tr> 
              <tr><td> GitHub.com</td></tr> 
            </table>
            <aside class="notes">
              <p>These 22 returned standards-compliant freshness
              lifetime for <em>all</em> responses (which could be
              across hosts)</p>
              <p>70 had some promising results (DC properties,
              last-modified, Etag, etc)</p>
              <p>I've googled all these, and that's basically all we
              have to go on.</p>
            </aside>

          </section>
          
          <section>
            <h3>Contingency Table test</h3>
            
            <p>We can do a statistical test to see if certain headers
            occur significantly more frequently.</p>
            
            <p class="fragment">Pearson's &chi;<sup>2</sup> test with simulated <i>p</i>-value
	    (based on 10000 replicates)</p>
            
            <dl class="fragment">
              <dt>For standards-compliant caching</dt>
              <dd>Supports that some server may be better than others at
              <i>p</i>-value&nbsp;=&nbsp;0.0001.</dd>
              <dt>For other usable features</dt>
              <dd>Supports that some server may be better than others at
              <i>p</i>-value&nbsp;=&nbsp;0.0001.</dd>
            </dl>
            
          </section>

        </section>

        <section>
          <section>
            <h2>Conclusions</h2>
            
            <ul>
              <li><strong>We found moderate uptake for HTTP caching and
              conditional requests</strong></li>
              <li class="fragment">Many resources change slowly, but
              standard-compliant cache doesn't reflect this</li>
              <li class="fragment">Errors are common, but not in caching headers</li>
              <li class="fragment">Possible to compute heuristic
              freshness from headers or Dublin Core in many cases</li>
              <li class="fragment">Conditional requests seldomly
              supported on SPARQL endpoints, but standards-compliant
              freshness lifetimes have been seen</li>
            </ul>

          </section>
          
          <section>
            <h3>Hall of Fame</h3>
            <ul>
              <li>DBPedia</li>
              <li>Dydra</li>
              <li>RDF::LinkedData</li>
              <li>Graphity</li>
              <li>Callimachus</li>
              <li>Uniprot</li>
            </ul>
            
            <aside class="notes">
	      <p>Uniprot had last-modified, As of last week, provides Expires header
              </p>
              <p>but it is easy in all major servers, Apache, nginx,
              Virtuoso, the hard part is management</p>
            </aside>
            
          </section>
        </section>
      
        <section>
          <section>
            <h2>Future work</h2>

            <ul>
              <li>Learn change frequency of resources <span class="fragment">(but please
              respect the standards!)</span></li>
              <li class="fragment">Do curated collections (e.g. LOV, SPARQLES) have
              different characteristics?</li>
              <li class="fragment">Understand what the differences
              between implementations are based on fingerprinting</li>
              <li class="fragment">User support systems to help
              estimate freshness lifetime</li>
              <li class="fragment">SPARQL caching based on prefetching
              results for query answering on proxy</li>
              <li class="fragment">Understanding the actual impact of
              caching of data</li>
            </ul>
            <aside class="notes">
              <ul>
		<li>So far, the server has been assumed
              cooperative.</li>
		<li>Better statistical methods than used here
              needed.</li><li> We haven't studied if caching really
              matters.</li></p>
            </aside>

          </section>

          <section>
            <h3>Recommendations</h3>

            <ul>
              <li>You should set cache headers, on a best-effort
              basis!</li>
              <li class="fragment">Framework authors should make it easy to be
              accurate</li>
              <li class="fragment">If headers can't be set, set <tt>dct:valid</tt> and
              <tt>dct:modified</tt></li>
              <li class="fragment">DBMS authors should make it much cheaper to retrieve
              a modification time of a subgraph than to retrieve the
              graph itself.</li>
              <li class="fragment">A change periodicity predicate should be
              standardized in VoID</li>
              <li class="fragment">For now, caches are key-value databases, accept that
              for short-term impact</li>
            </ul>
            
            <aside class="notes">
              <p>The focus of this work is descriptive, and this
              hasn't been a study of whether caching is actually
              important. Given my practical experience it would be
              surprising if it isn't </p>
            </aside>

          </section>
        </section>

        <section>
          <section>
            <h1>Thanks</h1>
          </section>
        </section>



      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    
    <script>
      
      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,
      
      transition: 'slide', // none/fade/slide/convex/concave/zoom
      
      // Optional reveal.js plugins
      dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true },
      { src: 'plugin/notes/notes.js', async: true }
      ]
      });
      
    </script>
    
    <script>//<![CDATA[
    document.write('<script src="//' + (location.hostname || 'localhost') + ':35729/livereload.js?snipver=1"><\/script>')
    //]]></script>

  </body>
</html>
